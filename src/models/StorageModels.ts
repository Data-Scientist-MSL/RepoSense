/**
 * Storage & Deliverables Model
 * =============================
 * 
 * Enterprise-grade directory structure and discovery for RepoSense artifacts.
 * Single authoritative location: .reposense/ (workspace-local, git-ignored)
 * 
 * Version: 1.0
 * Status: Production-ready specification
 */

// ============================================================================
// TIER 1: LOCAL RUN-SCOPED DELIVERABLES (Authoritative)
// ============================================================================

/**
 * RepoSense Workspace Structure
 * 
 * Root: .reposense/ (add to .gitignore)
 * 
 * .reposense/
 * ├── config/
 * │   └── reposense.config.json       ← User settings (persistent)
 * ├── cache/
 * │   ├── ast/                        ← AST cache (performance optimization)
 * │   └── analysis/                   ← Analysis cache
 * ├── runs/                           ← Immutable run history
 * │   ├── run-2026-01-20T22-14-31Z/
 * │   ├── run-2026-01-19T18-01-04Z/
 * │   └── ...
 * ├── latest -> runs/<currentRunId>   ← Symlink to latest run
 * ├── index.json                      ← Global index of all runs
 * └── .reposenseignore                ← Optional: what to exclude
 */

export interface RepoSenseWorkspace {
  rootDir: string; // Workspace root containing .reposense/
  reposenseDir: string; // .reposense/ directory path
  configFile: string; // .reposense/config/reposense.config.json
  cacheDir: string; // .reposense/cache/
  runsDir: string; // .reposense/runs/
  latestRunDir: string; // Resolved from .reposense/latest symlink
  indexFile: string; // .reposense/index.json
}

/**
 * Global Run Index
 * 
 * Located: .reposense/index.json
 * Purpose: Discover all runs, quick lookup, history
 */
export interface RepoSenseIndex {
  version: string; // Schema version
  workspace: {
    path: string;
    repositoryName: string;
    createdAt: string;
  };
  runs: RunIndexEntry[];
  latestRunId: string;
  stats: {
    totalRuns: number;
    successfulRuns: number;
    failedRuns: number;
    lastRunAt: string;
  };
}

/**
 * Run Index Entry
 * 
 * One entry per run in index.json
 */
export interface RunIndexEntry {
  runId: string; // Timestamp-based: run-2026-01-20T22-14-31Z
  timestamp: string; // ISO 8601
  status: 'SUCCESS' | 'FAILED' | 'PARTIAL';
  duration: number; // milliseconds
  summary: {
    totalEndpoints: number;
    testedEndpoints: number;
    coverage: number; // percentage
    gaps: number;
    criticalGaps: number;
  };
  artifacts: {
    hasReport: boolean;
    hasDiagrams: boolean;
    hasEvidence: boolean;
    hasTests: boolean;
    hasDiffs: boolean;
  };
  directory: string; // relative path: runs/run-2026-01-20T22-14-31Z
}

// ============================================================================
// RUN STRUCTURE: What lives inside each run
// ============================================================================

/**
 * Run Directory Layout
 * 
 * Each run is fully self-contained and immutable.
 * 
 * .reposense/runs/run-2026-01-20T22-14-31Z/
 * ├── meta.json                 ← Run metadata + execution details
 * ├── scan.json                 ← Raw analysis output (immutable backup)
 * ├── graph.json                ← RunGraph (canonical normalized data)
 * ├── plan.json                 ← TestPlan generated by TestGenerator
 * │
 * ├── report/
 * │   ├── report.json           ← Canonical report model
 * │   ├── report.md             ← Markdown export
 * │   ├── report.html           ← HTML export
 * │   └── summary.txt           ← One-page summary
 * │
 * ├── diagrams/
 * │   ├── system-context.mmd    ← Mermaid source (canonical)
 * │   ├── api-flow.mmd
 * │   ├── coverage-map.mmd
 * │   ├── diagrams.json         ← Diagram registry + metadata
 * │   └── exports/
 * │       ├── system-context.svg
 * │       ├── system-context.png
 * │       ├── api-flow.svg
 * │       └── coverage-map.png
 * │
 * ├── evidence/
 * │   ├── screenshots/          ← Test execution screenshots
 * │   ├── videos/               ← Screen recordings
 * │   ├── network-traces/       ← Network logs (HAR, WireShark)
 * │   ├── console-logs/         ← Browser/server console output
 * │   ├── evidence-index.json   ← Gap → Test → Artifact mapping
 * │   └── evidence-manifest.json ← File metadata + checksums
 * │
 * ├── tests/
 * │   ├── playwright/           ← Generated Playwright tests
 * │   │   ├── users.get.spec.ts
 * │   │   ├── users.post.spec.ts
 * │   │   └── ...
 * │   ├── cypress/              ← Generated Cypress tests
 * │   │   └── ...
 * │   ├── jest/                 ← Generated Jest tests
 * │   │   └── ...
 * │   ├── metadata.json         ← Test framework info + status
 * │   └── preview.json          ← Preview: NOT applied to repo yet
 * │
 * ├── diffs/
 * │   ├── fix-users-endpoint.patch
 * │   ├── add-auth-guard.patch
 * │   ├── enable-cors.patch
 * │   ├── diff-index.json       ← Metadata + apply status
 * │   └── preview.json          ← Preview: what would change
 * │
 * ├── execution/
 * │   ├── test-results.json     ← Pass/fail + metrics
 * │   ├── performance.json      ← Execution timing
 * │   ├── errors.log            ← Any errors during run
 * │   └── timeline.json         ← Execution phases + durations
 * │
 * └── run-metadata.json         ← Overall run info
 *     ├── runId
 *     ├── timestamp
 *     ├── workspace
 *     ├── configuration
 *     ├── versions (RepoSense, Node, Browsers)
 *     └── user (optional)
 */

export interface RunMetadata {
  runId: string; // e.g., run-2026-01-20T22-14-31Z
  timestamp: string; // ISO 8601, UTC
  status: 'IN_PROGRESS' | 'SUCCESS' | 'FAILED' | 'PARTIAL' | 'CANCELLED';
  workspace: {
    repositoryRoot: string;
    repositoryName: string;
    branch?: string;
    commit?: string;
  };
  execution: {
    startTime: string;
    endTime?: string;
    durationMs?: number;
    phases: {
      scan: { durationMs: number; status: string };
      analysis: { durationMs: number; status: string };
      graphBuilding: { durationMs: number; status: string };
      planning: { durationMs: number; status: string };
      execution?: { durationMs: number; status: string };
    };
  };
  versions: {
    repoSense: string;
    node: string;
    playwright?: string;
    cypress?: string;
  };
  user?: {
    email: string;
    name: string;
  };
  config: {
    testFrameworks: string[];
    excludePatterns?: string[];
    scanDepth?: number;
  };
}

// ============================================================================
// ARTIFACT: Reports
// ============================================================================

/**
 * Report Artifact Location
 * 
 * All report formats in: .reposense/runs/<runId>/report/
 */
export interface ReportArtifact {
  jsonPath: string; // report.json (canonical model)
  markdownPath: string; // report.md (human-readable)
  htmlPath: string; // report.html (for sharing)
  summaryPath?: string; // summary.txt (one-page)
}

// ============================================================================
// ARTIFACT: Diagrams
// ============================================================================

/**
 * Diagram Artifact Location
 * 
 * All diagrams in: .reposense/runs/<runId>/diagrams/
 * 
 * KEY PRINCIPLE: Mermaid is the SOURCE, images are DERIVED
 * - system-context.mmd is canonical
 * - system-context.svg/png are re-generated from .mmd if missing
 */
export interface DiagramArtifact {
  mermaidDir: string; // location of .mmd files
  exportDir: string; // location of SVG, PNG, PDF exports
  registryPath: string; // diagrams.json (metadata)
  mermaidSourceFiles: {
    systemContext: string; // system-context.mmd
    apiFlow: string; // api-flow.mmd
    coverageMap: string; // coverage-map.mmd
  };
  exportFiles: {
    systemContextSvg?: string;
    systemContextPng?: string;
    apiFlowSvg?: string;
    apiFlowPng?: string;
    coverageMapSvg?: string;
    coverageMapPng?: string;
  };
}

// ============================================================================
// ARTIFACT: Evidence (Audit-Grade)
// ============================================================================

/**
 * Evidence Artifact Location
 * 
 * All evidence in: .reposense/runs/<runId>/evidence/
 * 
 * Evidence is the PROOF that gaps were tested and validated.
 */
export interface EvidenceArtifact {
  indexPath: string; // evidence-index.json (gap → test → artifact mapping)
  manifestPath: string; // evidence-manifest.json (file metadata)
  screenshotsDir: string;
  videosDir: string;
  networkTracesDir: string;
  consoleLogsDir: string;
}

/**
 * Evidence Index
 * 
 * Enables: "Show me evidence for gap X"
 */
export interface EvidenceIndex {
  version: string;
  runId: string;
  timestamp: string;
  entries: EvidenceIndexEntry[];
}

/**
 * Evidence Index Entry
 * 
 * Links: gap → test case → execution artifacts
 */
export interface EvidenceIndexEntry {
  gapId: string; // e.g., gap-123
  endpoint: {
    method: string;
    path: string;
  };
  linkedTests: Array<{
    testId: string;
    testName: string;
    framework: string;
    executionTimestamp: string;
    passed: boolean;
  }>;
  artifacts: Array<{
    type: 'SCREENSHOT' | 'VIDEO' | 'NETWORK_TRACE' | 'CONSOLE_LOG';
    filename: string;
    path: string;
    timestamp: string;
    size: number; // bytes
    mimeType: string;
  }>;
  confidence: number;
  notes?: string;
}

/**
 * Evidence Manifest
 * 
 * Checksum and metadata for every artifact
 */
export interface EvidenceManifest {
  version: string;
  runId: string;
  files: Array<{
    path: string; // relative to evidence/
    size: number; // bytes
    hash: string; // SHA256
    timestamp: string;
    type: string;
  }>;
  totalSize: number;
  totalFiles: number;
}

// ============================================================================
// ARTIFACT: Tests (Generated, Not Applied)
// ============================================================================

/**
 * Generated Tests Location
 * 
 * Tests are in: .reposense/runs/<runId>/tests/
 * 
 * CRITICAL: Tests are NOT copied to repo until user approves.
 * Stored here as preview + metadata.
 */
export interface GeneratedTestsArtifact {
  metadataPath: string; // metadata.json
  previewPath: string; // preview.json
  playwrightDir: string;
  cypressDir: string;
  jestDir: string;
}

/**
 * Test Metadata
 */
export interface TestMetadata {
  version: string;
  runId: string;
  timestamp: string;
  summary: {
    totalTestsGenerated: number;
    byFramework: Record<string, number>; // { playwright: 12, cypress: 5, jest: 8 }
    estimatedCoverageIncrease: number; // percentage
    estimatedEffort: 'QUICK' | 'MEDIUM' | 'INVOLVED'; // to integrate
  };
  frameworks: Array<{
    framework: string;
    testCount: number;
    files: string[]; // relative paths
    status: 'READY' | 'NEEDS_REVIEW' | 'NOT_APPLICABLE';
  }>;
  preview: {
    applied: boolean; // false (not yet applied to repo)
    applyDate?: string;
    appliedBy?: string;
  };
}

// ============================================================================
// ARTIFACT: Diffs (Remediation Patches)
// ============================================================================

/**
 * Remediation Diffs Location
 * 
 * Patches are in: .reposense/runs/<runId>/diffs/
 * 
 * Each patch is a unified diff that can be:
 * - Previewed
 * - Applied
 * - Reviewed for conflicts
 * - Reverted
 */
export interface RemediationDiffsArtifact {
  indexPath: string; // diff-index.json
  previewPath: string; // preview.json (what would change)
  patchDir: string; // all .patch files
}

/**
 * Diff Index
 */
export interface DiffIndex {
  version: string;
  runId: string;
  timestamp: string;
  diffs: Array<{
    diffId: string;
    patchFile: string;
    title: string;
    description?: string;
    type: 'CODE_PATCH' | 'TEST_GENERATION' | 'CONFIG_FIX';
    relatedGapId?: string;
    estimatedEffort: 'S' | 'M' | 'L';
    status: 'PREVIEW' | 'APPLIED' | 'REJECTED' | 'REVERTED';
    appliedDate?: string;
    appliedBy?: string;
  }>;
}

// ============================================================================
// TIER 2: OPTIONAL COMMITTED DELIVERABLES
// ============================================================================

/**
 * Export Targets (User-Driven)
 * 
 * RepoSense NEVER auto-commits. Users choose what to export.
 * 
 * Common export paths:
 * /docs/reposense/
 * /tests/generated/
 * /artifacts/
 */
export interface ExportTarget {
  location: 'REPO' | 'CI_ARTIFACT' | 'CLOUD_STORAGE';
  path: string; // where to export
  what: {
    includeReports: boolean;
    includeDiagrams: boolean;
    includeEvidenceSummary: boolean; // NOT full evidence (too large)
    includeGeneratedTests: boolean;
    includeRemediationDiffs: boolean;
  };
  format: {
    reports: 'JSON' | 'MARKDOWN' | 'HTML';
    diagrams: 'MERMAID' | 'SVG' | 'PNG';
    bundle: 'ZIP' | 'TAR' | 'DIRECTORY';
  };
}

/**
 * Committed Report Location (if exported)
 * 
 * /docs/reposense/reports/
 * └── 2026-01-api-health.md
 */
export interface CommittedReportLocation {
  directory: string; // /docs/reposense/reports/
  format: string; // MARKDOWN
  naming: string; // <YYYY-MM>-<focus-area>.md
}

/**
 * Committed Tests Location (if exported)
 * 
 * /tests/generated/reposense/
 * ├── playwright/
 * ├── cypress/
 * └── jest/
 */
export interface CommittedTestsLocation {
  directory: string; // /tests/generated/reposense/
  byFramework: boolean; // organized by framework
  includedFromRun: string; // which run ID was exported
}

/**
 * Committed Evidence Bundle (CI/CD)
 * 
 * /artifacts/
 * └── reposense-run-2026-01-20.zip
 */
export interface CommittedEvidenceBundle {
  filename: string; // reposense-run-<timestamp>.zip
  location: string; // /artifacts/ or CI artifact storage
  contents: {
    reportHtml: boolean;
    diagrams: boolean;
    evidenceSummary: boolean;
    metadata: boolean;
  };
}

// ============================================================================
// DISCOVERY LAYER: How ChatBot & UI find artifacts
// ============================================================================

/**
 * Run Discovery Service
 * 
 * Answers: "Find me the latest report", "Compare runs", "Get evidence for gap X"
 */
export interface RunDiscovery {
  /**
   * Find all runs in workspace
   */
  listRuns(workspace: RepoSenseWorkspace): Promise<RunIndexEntry[]>;

  /**
   * Get latest run
   */
  getLatestRun(workspace: RepoSenseWorkspace): Promise<RunIndexEntry>;

  /**
   * Get specific run by ID
   */
  getRun(workspace: RepoSenseWorkspace, runId: string): Promise<RunIndexEntry>;

  /**
   * Load full metadata for a run
   */
  loadRunMetadata(
    workspace: RepoSenseWorkspace,
    runId: string
  ): Promise<RunMetadata>;

  /**
   * Find evidence for a gap
   */
  findEvidenceForGap(
    workspace: RepoSenseWorkspace,
    runId: string,
    gapId: string
  ): Promise<EvidenceIndexEntry>;

  /**
   * Compare two runs (delta)
   */
  compareRuns(
    workspace: RepoSenseWorkspace,
    runId1: string,
    runId2: string
  ): Promise<{
    endpointDiff: number;
    coverageDiff: number;
    newGaps: number;
    resolvedGaps: number;
  }>;
}

// ============================================================================
// PERSISTENCE LAYER
// ============================================================================

/**
 * Run Storage
 * 
 * Interface for persisting and retrieving run data
 */
export interface RunStorage {
  /**
   * Initialize workspace structure
   */
  initializeWorkspace(rootDir: string): Promise<void>;

  /**
   * Create new run directory
   */
  createRun(
    workspace: RepoSenseWorkspace,
    metadata: RunMetadata
  ): Promise<string>;

  /**
   * Save artifact to run
   */
  saveArtifact(
    workspace: RepoSenseWorkspace,
    runId: string,
    type: 'report' | 'diagrams' | 'evidence' | 'tests' | 'diffs',
    data: any
  ): Promise<void>;

  /**
   * Load artifact from run
   */
  loadArtifact(
    workspace: RepoSenseWorkspace,
    runId: string,
    type: string
  ): Promise<any>;

  /**
   * Update global index
   */
  updateIndex(
    workspace: RepoSenseWorkspace,
    entry: RunIndexEntry
  ): Promise<void>;

  /**
   * Finalize run (mark as complete)
   */
  finalizeRun(
    workspace: RepoSenseWorkspace,
    runId: string,
    status: 'SUCCESS' | 'FAILED'
  ): Promise<void>;
}


